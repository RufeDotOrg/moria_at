// Generated by codegen.sh
_Static_assert(OF2(256), "ARR_USE requires a power of 2");
GAME int monD[256];
GAME int mon_usedD;
GAME struct monS entity_monD[256];
static struct monS*
mon_use()
{
  int it = mon_usedD;
  int next = it + 1;
  if (next >= 256) return &entity_monD[0];
  int eid = monD[it];
  if (!eid) {
    eid = next;
  } else {
    eid += 256;
  }
  monD[it] = eid;
  mon_usedD = next;
  if (COMMON_DEBUG) {
    LOGFMT(
        "mon"
        " ALLOC (it %d eid %d) kUsed %d",
        it, eid, mon_usedD);
  }
  struct monS* ent = &AS(entity_monD, eid);
  ent->id = eid;
  return ent;
}
static struct monS*
mon_get(int eid)
{
  struct monS* dflt = entity_monD;
  struct monS* ent = &AS(entity_monD, eid);
  return ent->id == eid ? ent : dflt;
}
static int
mon_index(struct monS* ent)
{
  return AM(monD, ent->id);
}
static void
mon_unuse(struct monS* ent)
{
  int eid = ent->id;
  int it = 0;
  for (; it < AL(monD); ++it) {
    if (monD[it] == eid) break;
  }
  if (it < mon_usedD) {
    int swap_it = mon_usedD - 1;
    int swap_eid = monD[swap_it];
    mon_usedD -= 1;
    if (COMMON_DEBUG) {
      LOGFMT(
          "mon"
          " FREE (it %d swap_it %d) (eid %d vs swap_eid %d) kUsed %d",
          it, swap_it, eid, swap_eid, mon_usedD);
    }
    int xchg = eid ^ swap_eid;
    monD[swap_it] ^= xchg;
    monD[it] ^= xchg;
  }
  *ent = DFT(struct monS);
};
