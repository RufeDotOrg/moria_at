// Generated by codegen.sh
_Static_assert(OF2(256), "ARR_USE requires a power of 2");
GAME int objD[256];
GAME int obj_usedD;
GAME struct objS entity_objD[256];
static struct objS*
obj_use()
{
  int it = obj_usedD;
  int next = it + 1;
  if (next >= 256) return &entity_objD[0];
  int eid = objD[it];
  if (!eid) {
    eid = next;
  } else {
    eid += 256;
  }
  objD[it] = eid;
  obj_usedD = next;
  if (COMMON_DEBUG) {
    LOGFMT(
        "obj"
        " ALLOC (it %d eid %d) kUsed %d",
        it, eid, obj_usedD);
  }
  struct objS* ent = &AS(entity_objD, eid);
  ent->id = eid;
  return ent;
}
static struct objS*
obj_get(int eid)
{
  struct objS* dflt = entity_objD;
  struct objS* ent = &AS(entity_objD, eid);
  return ent->id == eid ? ent : dflt;
}
static int
obj_index(struct objS* ent)
{
  return AM(objD, ent->id);
}
static void
obj_unuse(struct objS* ent)
{
  int eid = ent->id;
  int it = 0;
  for (; it < AL(objD); ++it) {
    if (objD[it] == eid) break;
  }
  if (it < obj_usedD) {
    int swap_it = obj_usedD - 1;
    int swap_eid = objD[swap_it];
    obj_usedD -= 1;
    if (COMMON_DEBUG) {
      LOGFMT(
          "obj"
          " FREE (it %d swap_it %d) (eid %d vs swap_eid %d) kUsed %d",
          it, swap_it, eid, swap_eid, obj_usedD);
    }
    int xchg = eid ^ swap_eid;
    objD[swap_it] ^= xchg;
    objD[it] ^= xchg;
  }
  *ent = DFT(struct objS);
};
